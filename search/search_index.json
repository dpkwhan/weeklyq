{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mission Statement \u00b6 Learn and practice kdb/q Topics on electronic trading in equities Weekly question Promote collaboration","title":"Home"},{"location":"#mission-statement","text":"Learn and practice kdb/q Topics on electronic trading in equities Weekly question Promote collaboration","title":"Mission Statement"},{"location":"2019/2019.12.23/","text":"","title":"2019.12.23"},{"location":"2019/2019.12.30/","text":"","title":"2019.12.30"},{"location":"2020/2020.02.17/","text":"Introduction \u00b6 In the algorithmic trading world, parameterization is so common that some algorithms are configured with hundreds or thousands of parameters. An algorithmic parent order can easily has hundreds of parameters and some of which are exposed to algorithm users so that they can update the order attributes. For example, the participation rate of a POV (Percent Of Volume) order can be amended by end users at any time during the trading duration. A common question encountered in the analysis of algorithm and/or smart order router behavior is what parameters are modified, and how they are updated when an amend event is initiated by an algorithmic trader. Question \u00b6 Below is an example history of a few selected parameters of a POV order. Create a table to show the parameter history with each parameter name as the column name in the table. You need to treat the change in order quantity and/or price limit the same as parameter change. paramTbl:([]time:`time$();orderQty:`long$();limitPrice:`float$();params:()); `paramTbl insert (09:30:56.123;500000;0n;`StartTime`PovRate!(10:00:00.000;0.08)); `paramTbl insert (09:35:44.735;500000;0n;`StartTime`PovRate!(09:40:00.000;0.08)); `paramTbl insert (10:01:25.941;500000;0n;`StartTime`PovRate!(09:40:00.000;0.12)); `paramTbl insert (10:10:32.356;500000;0n;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (10:30:39.475;500000;45.23;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;600000;45.27;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;1000000;0n;`StartTime`PovRate!(09:40:00.000;0.15)); The final output table should look like as follows. Note in kdb table, the empty cell in the table below should have proper null value. time OrderQty LimitPrice StartTime PovRate MinPovRate MaxPovRate 09:30:56.123 500000 10:00:00.000 0.08 09:35:44.735 500000 09:40:00.000 0.08 10:01:25.941 500000 09:40:00.000 0.12 10:10:32.356 500000 09:40:00.000 0.12 0.1 0.14 10:30:39.475 500000 45.23 09:40:00.000 0.12 0.1 0.14 11:00:52.092 600000 45.27 09:40:00.000 0.12 0.1 0.14 11:00:52.092 1000000 09:40:00.000 0.15 Answer \u00b6 The answer below shows a few tips on dictionary manipulation: Use raze to merge a list of dictionaries with values of possible different types into a single dictionary Find the proper null values for each dictionary key Merge two dictionaries with join operator Merge two tables side by side {[paramTbl] / Merge all parameters into a single dictionary so as to get a full list of parameter names allParams:raze exec params from paramTbl; / Find the null value for each parameter name nullValues:(key allParams)!(enlist each value allParams)[;1]; / Create a table of \"parameter\" change history of order qty and limit price params1:select time,OrderQty:orderQty,LimitPrice:limitPrice from paramTbl; / Set a proper null value to parameters that are not present params2:exec {x,y}[nullValues;] each params from paramTbl; / Combine the normal parameters with the pseudo parameters params1,'params2 }[paramTbl]","title":"2020.02.17"},{"location":"2020/2020.02.17/#introduction","text":"In the algorithmic trading world, parameterization is so common that some algorithms are configured with hundreds or thousands of parameters. An algorithmic parent order can easily has hundreds of parameters and some of which are exposed to algorithm users so that they can update the order attributes. For example, the participation rate of a POV (Percent Of Volume) order can be amended by end users at any time during the trading duration. A common question encountered in the analysis of algorithm and/or smart order router behavior is what parameters are modified, and how they are updated when an amend event is initiated by an algorithmic trader.","title":"Introduction"},{"location":"2020/2020.02.17/#question","text":"Below is an example history of a few selected parameters of a POV order. Create a table to show the parameter history with each parameter name as the column name in the table. You need to treat the change in order quantity and/or price limit the same as parameter change. paramTbl:([]time:`time$();orderQty:`long$();limitPrice:`float$();params:()); `paramTbl insert (09:30:56.123;500000;0n;`StartTime`PovRate!(10:00:00.000;0.08)); `paramTbl insert (09:35:44.735;500000;0n;`StartTime`PovRate!(09:40:00.000;0.08)); `paramTbl insert (10:01:25.941;500000;0n;`StartTime`PovRate!(09:40:00.000;0.12)); `paramTbl insert (10:10:32.356;500000;0n;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (10:30:39.475;500000;45.23;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;600000;45.27;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;1000000;0n;`StartTime`PovRate!(09:40:00.000;0.15)); The final output table should look like as follows. Note in kdb table, the empty cell in the table below should have proper null value. time OrderQty LimitPrice StartTime PovRate MinPovRate MaxPovRate 09:30:56.123 500000 10:00:00.000 0.08 09:35:44.735 500000 09:40:00.000 0.08 10:01:25.941 500000 09:40:00.000 0.12 10:10:32.356 500000 09:40:00.000 0.12 0.1 0.14 10:30:39.475 500000 45.23 09:40:00.000 0.12 0.1 0.14 11:00:52.092 600000 45.27 09:40:00.000 0.12 0.1 0.14 11:00:52.092 1000000 09:40:00.000 0.15","title":"Question"},{"location":"2020/2020.02.17/#answer","text":"The answer below shows a few tips on dictionary manipulation: Use raze to merge a list of dictionaries with values of possible different types into a single dictionary Find the proper null values for each dictionary key Merge two dictionaries with join operator Merge two tables side by side {[paramTbl] / Merge all parameters into a single dictionary so as to get a full list of parameter names allParams:raze exec params from paramTbl; / Find the null value for each parameter name nullValues:(key allParams)!(enlist each value allParams)[;1]; / Create a table of \"parameter\" change history of order qty and limit price params1:select time,OrderQty:orderQty,LimitPrice:limitPrice from paramTbl; / Set a proper null value to parameters that are not present params2:exec {x,y}[nullValues;] each params from paramTbl; / Combine the normal parameters with the pseudo parameters params1,'params2 }[paramTbl]","title":"Answer"},{"location":"2020/2020.02.24/","text":"Introduction \u00b6 One common operation on a dictionary is to add an new key to an existing dictionary. This operation looks quite easy and straightforward at first sight, but there is a trap to fall into. Question \u00b6 Suppose you have a dictionary d defined as follows: q) d:`firstName`lastName!`Tom`Jerry How to add a new key age with value 37 to this dictionary? After adding the new key, the updated dictionary should look like: q) d firstName| Tom lastName | Jerry age | 37 Answer \u00b6 The immediate solution that comes to many people's mind is to add the new key age is: q) d[`age]:37 Unfortunately, a type error is thrown when doing that: q) d[`age]:37 'type [0] d[`age]:37 ^ The type error occurs because: The existing dictionary d is uniform, and The value type of new item age is different from the value type of the existing items in the dictionary Let's look at two different cases. Mixed Value Type \u00b6 A new key can be simply added by assigning the value to the new key when the existing dictionary's values are of mixed types. For example, the value of dictionary d2 has types of symbol and long , i.e. , (`Tom;`Jerry;10583) is of mixed type. q) d2:`firstName`lastName`zip!(`Tom;`Jerry;10583) q) d2 firstName| `Tom lastName | `Jerry zip | 10583 q) d2[`age]:37 / add a new item q) d2 firstName| `Tom lastName | `Jerry zip | 10583 age | 37 Uniform Value Type \u00b6 The new value has the same type as the existing dictionary's value q) d3:`firstName`lastName!`Tom`Jerry q) d3[`state]:`NY q) d3 firstName| Tom lastName | Jerry state | NY The new value's type is different from the type of the existing dictionary's value. In this case, we can create a second dictionary using the new key/value and then merge this dictionary with the existing dictionary. For example, q) d4:`firstName`lastName!`Tom`Jerry q) d4 firstName| Tom lastName | Jerry q) d4,(enlist `age)!(enlist 37) firstName| `Tom lastName | `Jerry age | 37 The right side of the join operator ( , ) above is a singleton dictionary. Note that both the key and the value of a dictionary are required to be lists, you must enlist atomic value to create a singleton dictionary. Summary \u00b6 The robust approach to insert a new item into an dictionary is first create a new dictionary using the new item and merge this new dictionary with the existing dictionary using the join operator .","title":"2020.02.24"},{"location":"2020/2020.02.24/#introduction","text":"One common operation on a dictionary is to add an new key to an existing dictionary. This operation looks quite easy and straightforward at first sight, but there is a trap to fall into.","title":"Introduction"},{"location":"2020/2020.02.24/#question","text":"Suppose you have a dictionary d defined as follows: q) d:`firstName`lastName!`Tom`Jerry How to add a new key age with value 37 to this dictionary? After adding the new key, the updated dictionary should look like: q) d firstName| Tom lastName | Jerry age | 37","title":"Question"},{"location":"2020/2020.02.24/#answer","text":"The immediate solution that comes to many people's mind is to add the new key age is: q) d[`age]:37 Unfortunately, a type error is thrown when doing that: q) d[`age]:37 'type [0] d[`age]:37 ^ The type error occurs because: The existing dictionary d is uniform, and The value type of new item age is different from the value type of the existing items in the dictionary Let's look at two different cases.","title":"Answer"},{"location":"2020/2020.02.24/#mixed-value-type","text":"A new key can be simply added by assigning the value to the new key when the existing dictionary's values are of mixed types. For example, the value of dictionary d2 has types of symbol and long , i.e. , (`Tom;`Jerry;10583) is of mixed type. q) d2:`firstName`lastName`zip!(`Tom;`Jerry;10583) q) d2 firstName| `Tom lastName | `Jerry zip | 10583 q) d2[`age]:37 / add a new item q) d2 firstName| `Tom lastName | `Jerry zip | 10583 age | 37","title":"Mixed Value Type"},{"location":"2020/2020.02.24/#uniform-value-type","text":"The new value has the same type as the existing dictionary's value q) d3:`firstName`lastName!`Tom`Jerry q) d3[`state]:`NY q) d3 firstName| Tom lastName | Jerry state | NY The new value's type is different from the type of the existing dictionary's value. In this case, we can create a second dictionary using the new key/value and then merge this dictionary with the existing dictionary. For example, q) d4:`firstName`lastName!`Tom`Jerry q) d4 firstName| Tom lastName | Jerry q) d4,(enlist `age)!(enlist 37) firstName| `Tom lastName | `Jerry age | 37 The right side of the join operator ( , ) above is a singleton dictionary. Note that both the key and the value of a dictionary are required to be lists, you must enlist atomic value to create a singleton dictionary.","title":"Uniform Value Type"},{"location":"2020/2020.02.24/#summary","text":"The robust approach to insert a new item into an dictionary is first create a new dictionary using the new item and merge this new dictionary with the existing dictionary using the join operator .","title":"Summary"},{"location":"2020/2020.03.02/","text":"Introduction \u00b6 The first thing to do in most quantitative analysis in the electronic trading is to determine the data scope, which covers two aspects: the sample period, i.e. the start and end date/time of the data the cross sectional space, i.e. the universe of securities included in the analysis A common approach to determine the security universe is to include the top n most actively traded symbols. Question \u00b6 Assuming a trade table, which has three columns: date , ticker and volume , is simulated with the function simulateTrades defined below. This function generates 500000 trades for all week days in March 2020. The stock ticker is generated as three random letters. The column volume indicates how many shares are traded. getTradingDays:{ firstDate:2020.03.01; lastDate:2020.03.31; dates:firstDate+til (lastDate-firstDate)+1; dates where not (dates mod 7) in 0 1 }; simulateTrades:{ nTrades:500000; tradingDays:getTradingDays[]; system \"S -314159\"; dates:nTrades?tradingDays; system \"S -314159\"; tickers:nTrades?`3; system \"S -314159\"; volumes:100*nTrades?1+til 100; ([]date:dates;ticker:tickers;volume:volumes) }; Find the top 10 symbols that are most actively traded (measured by total traded shares) on each day.","title":"2020.03.02"},{"location":"2020/2020.03.02/#introduction","text":"The first thing to do in most quantitative analysis in the electronic trading is to determine the data scope, which covers two aspects: the sample period, i.e. the start and end date/time of the data the cross sectional space, i.e. the universe of securities included in the analysis A common approach to determine the security universe is to include the top n most actively traded symbols.","title":"Introduction"},{"location":"2020/2020.03.02/#question","text":"Assuming a trade table, which has three columns: date , ticker and volume , is simulated with the function simulateTrades defined below. This function generates 500000 trades for all week days in March 2020. The stock ticker is generated as three random letters. The column volume indicates how many shares are traded. getTradingDays:{ firstDate:2020.03.01; lastDate:2020.03.31; dates:firstDate+til (lastDate-firstDate)+1; dates where not (dates mod 7) in 0 1 }; simulateTrades:{ nTrades:500000; tradingDays:getTradingDays[]; system \"S -314159\"; dates:nTrades?tradingDays; system \"S -314159\"; tickers:nTrades?`3; system \"S -314159\"; volumes:100*nTrades?1+til 100; ([]date:dates;ticker:tickers;volume:volumes) }; Find the top 10 symbols that are most actively traded (measured by total traded shares) on each day.","title":"Question"}]}