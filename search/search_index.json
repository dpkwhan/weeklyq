{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mission Statement Learn and practice kdb/q Topics on electronic trading in equities Weekly question Promote collaboration","title":"Home"},{"location":"#mission-statement","text":"Learn and practice kdb/q Topics on electronic trading in equities Weekly question Promote collaboration","title":"Mission Statement"},{"location":"2019/2019.12.23/","text":"","title":"2019.12.23"},{"location":"2019/2019.12.30/","text":"","title":"2019.12.30"},{"location":"2020/2020.02.17/","text":"Introduction In the electronic trading world, parameterization is so common that some Algorithms are configured with hundreds or thousands of parameters. An algorithmic order can easily has hundreds of parameters and some of which are exposed to users so that they can amend the order attibutes. For example, the participation rate of a POV (Percent Of Volume) order can be amended by users. A common question encountered in the our daily work is which parameters are modified and how it is changed when an amend happens. Question Below is an example history of a few selected parameters of a POV order. Create a table to show the parameter history with each parameter name as the column name in the table. You need to treat the change in order quantity and/or price limit the same as parameter change. paramTbl:([]time:`time$();orderQty:`long$();limitPrice:`float$();params:()); `paramTbl insert (09:30:56.123;500000;0n;`StartTime`ParticipationRate!(10:00:00.000;0.08)); `paramTbl insert (09:35:44.735;500000;0n;`StartTime`ParticipationRate!(09:40:00.000;0.08)); `paramTbl insert (10:01:25.941;500000;0n;`StartTime`ParticipationRate!(09:40:00.000;0.12)); `paramTbl insert (10:10:32.356;500000;0n;`StartTime`ParticipationRate`MinParcipationRate`MaxParcipationRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (10:30:39.475;500000;45.23;`StartTime`ParticipationRate`MinParcipationRate`MaxParcipationRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;600000;45.27;`StartTime`ParticipationRate`MinParcipationRate`MaxParcipationRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;1000000;0n;`StartTime`ParticipationRate!(09:40:00.000;0.15)); The final output table should look like as follows. Note in kdb table, the empty cell in the table below should have proper null value. time OrderQty LimitPrice StartTime ParticipationRate MinParcipationRate MaxParcipationRate 09:30:56.123 500000 10:00:00.000 0.08 09:35:44.735 500000 09:40:00.000 0.08 10:01:25.941 500000 09:40:00.000 0.12 10:10:32.356 500000 09:40:00.000 0.12 0.1 0.14 10:30:39.475 500000 45.23 09:40:00.000 0.12 0.1 0.14 11:00:52.092 600000 45.27 09:40:00.000 0.12 0.1 0.14 11:00:52.092 1000000 09:40:00.000 0.15 Answer The answer below shows a few tips about dictionary manipulation: Use raze to merge multiple dictionaries into a single dictionary Find the proper null values for each dictionary key Merge two dictionaries with comma Merge two tables side by side flattenParams:{[paramTbl] / Merge all parameter into a single dictionary so as to get a full list of parameter names allParams:raze exec params from paramTbl; / Find the null value for each parameter name nullValues:(key allParams)!(enlist each value allParams)[;1]; / Create a table of \"parameter\" change history of order qty and limit price params1:select time,OrderQty:orderQty,LimitPrice:limitPrice from paramTbl; / Set a proper null value to parameters that are not present params2:exec {x,y}[nullValues;] each params from paramTbl; / Combine the normal parameters with the pseudo parameters params1,'params2 }; flattenParams[paramTbl]","title":"2020.02.17"},{"location":"2020/2020.02.17/#introduction","text":"In the electronic trading world, parameterization is so common that some Algorithms are configured with hundreds or thousands of parameters. An algorithmic order can easily has hundreds of parameters and some of which are exposed to users so that they can amend the order attibutes. For example, the participation rate of a POV (Percent Of Volume) order can be amended by users. A common question encountered in the our daily work is which parameters are modified and how it is changed when an amend happens.","title":"Introduction"},{"location":"2020/2020.02.17/#question","text":"Below is an example history of a few selected parameters of a POV order. Create a table to show the parameter history with each parameter name as the column name in the table. You need to treat the change in order quantity and/or price limit the same as parameter change. paramTbl:([]time:`time$();orderQty:`long$();limitPrice:`float$();params:()); `paramTbl insert (09:30:56.123;500000;0n;`StartTime`ParticipationRate!(10:00:00.000;0.08)); `paramTbl insert (09:35:44.735;500000;0n;`StartTime`ParticipationRate!(09:40:00.000;0.08)); `paramTbl insert (10:01:25.941;500000;0n;`StartTime`ParticipationRate!(09:40:00.000;0.12)); `paramTbl insert (10:10:32.356;500000;0n;`StartTime`ParticipationRate`MinParcipationRate`MaxParcipationRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (10:30:39.475;500000;45.23;`StartTime`ParticipationRate`MinParcipationRate`MaxParcipationRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;600000;45.27;`StartTime`ParticipationRate`MinParcipationRate`MaxParcipationRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;1000000;0n;`StartTime`ParticipationRate!(09:40:00.000;0.15)); The final output table should look like as follows. Note in kdb table, the empty cell in the table below should have proper null value. time OrderQty LimitPrice StartTime ParticipationRate MinParcipationRate MaxParcipationRate 09:30:56.123 500000 10:00:00.000 0.08 09:35:44.735 500000 09:40:00.000 0.08 10:01:25.941 500000 09:40:00.000 0.12 10:10:32.356 500000 09:40:00.000 0.12 0.1 0.14 10:30:39.475 500000 45.23 09:40:00.000 0.12 0.1 0.14 11:00:52.092 600000 45.27 09:40:00.000 0.12 0.1 0.14 11:00:52.092 1000000 09:40:00.000 0.15","title":"Question"},{"location":"2020/2020.02.17/#answer","text":"The answer below shows a few tips about dictionary manipulation: Use raze to merge multiple dictionaries into a single dictionary Find the proper null values for each dictionary key Merge two dictionaries with comma Merge two tables side by side flattenParams:{[paramTbl] / Merge all parameter into a single dictionary so as to get a full list of parameter names allParams:raze exec params from paramTbl; / Find the null value for each parameter name nullValues:(key allParams)!(enlist each value allParams)[;1]; / Create a table of \"parameter\" change history of order qty and limit price params1:select time,OrderQty:orderQty,LimitPrice:limitPrice from paramTbl; / Set a proper null value to parameters that are not present params2:exec {x,y}[nullValues;] each params from paramTbl; / Combine the normal parameters with the pseudo parameters params1,'params2 }; flattenParams[paramTbl]","title":"Answer"},{"location":"2020/2020.02.24/","text":"Introduction One common operation on a dictionary is to add an new key to an existing dictionary. This operation looks quite easy and straightforward at first sight, but there is a trap to fall into. Question Suppose you have a dictionary d defined as follows: q) d:`firstName`lastName!`Tom`Jerry How to add a new key age with value 37 to this dictionary? After adding the new key, the updated dictionary should look like: q) d firstName| Tom lastName | Jerry age | 37 Answer The immediate solution that comes to many people's mind is to add the new key age is: q) d[`age]:37 Unfortunately, a type error is thrown when doing that: q) d[`age]:37 'type [0] d[`age]:37 ^ The type error occurs because: The existing dictionary d is uniform, and The value type of new item age is different from the value type of the existing items in the dictionary Let's look at two different cases. Mixed Value Type A new key can be simply added by assigning the value to the new key when the existing dictionary's values are of mixed types. For example, the value of dictionary d2 has types of symbol and long , i.e. , (`Tom;`Jerry;10583) is of mixed type. q) d2:`firstName`lastName`zip!(`Tom;`Jerry;10583) q) d2 firstName| `Tom lastName | `Jerry zip | 10583 q) d2[`age]:37 / add a new item q) d2 firstName| `Tom lastName | `Jerry zip | 10583 age | 37 Uniform Value Type The new value has the same type as the existing dictionary's value q) d3:`firstName`lastName!`Tom`Jerry q) d3[`state]:`NY q) d3 firstName| Tom lastName | Jerry state | NY The new value's type is different from the type of the existing dictionary's value. In this case, we can create a second dictonary using the new key/value and then merge this dictionary with the existing dictionary. For example, q) d4:`firstName`lastName!`Tom`Jerry q) d4 firstName| Tom lastName | Jerry q) d4,(enlist `age)!(enlist 37) firstName| `Tom lastName | `Jerry age | 37 Summary The robust approach to insert a new item into an dictionary is first create a new dictionary using the new item and merge this new dictionary with the existing dictionary using the join operator .","title":"2020.02.24"},{"location":"2020/2020.02.24/#introduction","text":"One common operation on a dictionary is to add an new key to an existing dictionary. This operation looks quite easy and straightforward at first sight, but there is a trap to fall into.","title":"Introduction"},{"location":"2020/2020.02.24/#question","text":"Suppose you have a dictionary d defined as follows: q) d:`firstName`lastName!`Tom`Jerry How to add a new key age with value 37 to this dictionary? After adding the new key, the updated dictionary should look like: q) d firstName| Tom lastName | Jerry age | 37","title":"Question"},{"location":"2020/2020.02.24/#answer","text":"The immediate solution that comes to many people's mind is to add the new key age is: q) d[`age]:37 Unfortunately, a type error is thrown when doing that: q) d[`age]:37 'type [0] d[`age]:37 ^ The type error occurs because: The existing dictionary d is uniform, and The value type of new item age is different from the value type of the existing items in the dictionary Let's look at two different cases.","title":"Answer"},{"location":"2020/2020.02.24/#mixed-value-type","text":"A new key can be simply added by assigning the value to the new key when the existing dictionary's values are of mixed types. For example, the value of dictionary d2 has types of symbol and long , i.e. , (`Tom;`Jerry;10583) is of mixed type. q) d2:`firstName`lastName`zip!(`Tom;`Jerry;10583) q) d2 firstName| `Tom lastName | `Jerry zip | 10583 q) d2[`age]:37 / add a new item q) d2 firstName| `Tom lastName | `Jerry zip | 10583 age | 37","title":"Mixed Value Type"},{"location":"2020/2020.02.24/#uniform-value-type","text":"The new value has the same type as the existing dictionary's value q) d3:`firstName`lastName!`Tom`Jerry q) d3[`state]:`NY q) d3 firstName| Tom lastName | Jerry state | NY The new value's type is different from the type of the existing dictionary's value. In this case, we can create a second dictonary using the new key/value and then merge this dictionary with the existing dictionary. For example, q) d4:`firstName`lastName!`Tom`Jerry q) d4 firstName| Tom lastName | Jerry q) d4,(enlist `age)!(enlist 37) firstName| `Tom lastName | `Jerry age | 37","title":"Uniform Value Type"},{"location":"2020/2020.02.24/#summary","text":"The robust approach to insert a new item into an dictionary is first create a new dictionary using the new item and merge this new dictionary with the existing dictionary using the join operator .","title":"Summary"},{"location":"2020/2020.03.02/","text":"","title":"2020.03.02"}]}