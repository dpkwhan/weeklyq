{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mission Statement \u00b6 Learn and practice kdb/q Topics on electronic trading in equities Weekly question Promote collaboration","title":"Home"},{"location":"#mission-statement","text":"Learn and practice kdb/q Topics on electronic trading in equities Weekly question Promote collaboration","title":"Mission Statement"},{"location":"2019/2019.12.23/","text":"","title":"2019.12.23"},{"location":"2019/2019.12.30/","text":"","title":"2019.12.30"},{"location":"2020/2020.01.20/","text":"Introduction \u00b6 A set of child orders may be created in each evaluation cycle of a Smart Order Router (SOR) and these orders might be distributed among multiple price levels and even across different trading venues. The code below simulates this order creation process. In each evaluation cycle, five orders are generated, each of which has different price but has the save evaluation id. In this example, there are two parent orders: one for BUY and one for SELL. genCO:{[parentId;waveId;side] n:-5; system \"S -314159\"; ids:`long$.z.N+n?1000; system \"S -314159\"; prices:100+0.01*n?100; system \"S -314159\"; sizes:100*1+n?10; ([] poid:parentId;wid:waveId;coid:ids;side:side;price:prices;size:sizes) }; genOrders:{ buyOrders:raze {poid:`long$22:32:12.163;genCO[poid;x;`BUY]} each 101+til 20; sellOrders:raze {poid:`long$23:32:12.163;genCO[poid;x;`SELL]} each 101+til 20; buyOrders,sellOrders }; orders:genOrders[]; Question \u00b6 Find the most aggressive order, i.e. buy order with the highest price and sell order with the lowest price, within each evaluation cycle. Answer \u00b6 The following two approaches are proposed: Method 1 raze {[s] f:$[s=`BUY;max;min]; select from orders where side=s,price=(f;price) fby ([] poid;wid) } each `BUY`SELL In above implementation: Use raze to merge multiple conforming tables into a single table Conditional selection operator ($) is used to select which function to use based on the order side To group on multiple columns in a fby , tabulate them in group Method 2 { data:`poid`wid`p xasc update p:?[side=`BUY;price;-1*price] from orders; data:delete p from data; 0!select by poid,wid from data }[] A few notes about the second implementation: select by group from table gives you the last row in a group Use 0! on to remove key(s) of a keyed table","title":"2020.01.20"},{"location":"2020/2020.01.20/#introduction","text":"A set of child orders may be created in each evaluation cycle of a Smart Order Router (SOR) and these orders might be distributed among multiple price levels and even across different trading venues. The code below simulates this order creation process. In each evaluation cycle, five orders are generated, each of which has different price but has the save evaluation id. In this example, there are two parent orders: one for BUY and one for SELL. genCO:{[parentId;waveId;side] n:-5; system \"S -314159\"; ids:`long$.z.N+n?1000; system \"S -314159\"; prices:100+0.01*n?100; system \"S -314159\"; sizes:100*1+n?10; ([] poid:parentId;wid:waveId;coid:ids;side:side;price:prices;size:sizes) }; genOrders:{ buyOrders:raze {poid:`long$22:32:12.163;genCO[poid;x;`BUY]} each 101+til 20; sellOrders:raze {poid:`long$23:32:12.163;genCO[poid;x;`SELL]} each 101+til 20; buyOrders,sellOrders }; orders:genOrders[];","title":"Introduction"},{"location":"2020/2020.01.20/#question","text":"Find the most aggressive order, i.e. buy order with the highest price and sell order with the lowest price, within each evaluation cycle.","title":"Question"},{"location":"2020/2020.01.20/#answer","text":"The following two approaches are proposed: Method 1 raze {[s] f:$[s=`BUY;max;min]; select from orders where side=s,price=(f;price) fby ([] poid;wid) } each `BUY`SELL In above implementation: Use raze to merge multiple conforming tables into a single table Conditional selection operator ($) is used to select which function to use based on the order side To group on multiple columns in a fby , tabulate them in group Method 2 { data:`poid`wid`p xasc update p:?[side=`BUY;price;-1*price] from orders; data:delete p from data; 0!select by poid,wid from data }[] A few notes about the second implementation: select by group from table gives you the last row in a group Use 0! on to remove key(s) of a keyed table","title":"Answer"},{"location":"2020/2020.01.27/","text":"Introduction \u00b6 NYSE TAQ data provides T+1 trades reported to SIP and each trade has some basic information like timestamp, price, exchange, volume and trade qualifiers. The open/close auction trade on the primary exchange is marked by qualifiers 0 and 6 , respectively. Define the daily volume as the total volume traded between the open/close auction trades on the primary, inclusively. genTrades:{[seed;nTrades] / Randomly generate each trade's timestamp system \"S \",string seed; times:`time$09:28:00.000+nTrades?392*60*1000; / Randomly generate trade size system \"S \",string seed; volumes:`long$100*1+nTrades?10; / Randomly generate each trade's sale condition system \"S \",string seed; saleConditions:{x?`B`C`H`L`N`P`R`T`U`V`X`Z`7`4`5`8} each nTrades?3; / Create a table of trades trades:([] time:times;volume:volumes;saleCondition:saleConditions); / Add the open and close auction trades trades:trades upsert (`time$09:30:00.000+rand 60000;24700j;`O`X); trades:trades upsert (`time$16:00:00.000+rand 2000;53800j;enlist `6); / Sort the trades time by time `time xasc trades }; simTrades:genTrades[-314159;10000]; simTrades Question \u00b6 To simplify the question, it is assumed that open/close auction trades are ALWAYS present. The function genTrades above simulates 10,002 trades. Note that each trade has up to two sale condition codes. Find the total volume between the two auction trades, inclusively. Answer \u00b6 We just need to find the timestamp of the two auction trades and then sum up volume of all trades between these two auction trades. This can be done like: auctionTimes:exec time from simTrades where any each saleCondition like\\: \"*[O6]*\"; select sum volume from simTrades where time within auctionTimes A few notable points worth mentioning: any each saleCondition like\\: \"*[O6]*\" : This where clause identifies the open/close auction trades. exec time from simTrades... : Extract the open and close auction time as a list of two elements. The first element is the time for open auction trade and the second is for close auction trade.","title":"2020.01.27"},{"location":"2020/2020.01.27/#introduction","text":"NYSE TAQ data provides T+1 trades reported to SIP and each trade has some basic information like timestamp, price, exchange, volume and trade qualifiers. The open/close auction trade on the primary exchange is marked by qualifiers 0 and 6 , respectively. Define the daily volume as the total volume traded between the open/close auction trades on the primary, inclusively. genTrades:{[seed;nTrades] / Randomly generate each trade's timestamp system \"S \",string seed; times:`time$09:28:00.000+nTrades?392*60*1000; / Randomly generate trade size system \"S \",string seed; volumes:`long$100*1+nTrades?10; / Randomly generate each trade's sale condition system \"S \",string seed; saleConditions:{x?`B`C`H`L`N`P`R`T`U`V`X`Z`7`4`5`8} each nTrades?3; / Create a table of trades trades:([] time:times;volume:volumes;saleCondition:saleConditions); / Add the open and close auction trades trades:trades upsert (`time$09:30:00.000+rand 60000;24700j;`O`X); trades:trades upsert (`time$16:00:00.000+rand 2000;53800j;enlist `6); / Sort the trades time by time `time xasc trades }; simTrades:genTrades[-314159;10000]; simTrades","title":"Introduction"},{"location":"2020/2020.01.27/#question","text":"To simplify the question, it is assumed that open/close auction trades are ALWAYS present. The function genTrades above simulates 10,002 trades. Note that each trade has up to two sale condition codes. Find the total volume between the two auction trades, inclusively.","title":"Question"},{"location":"2020/2020.01.27/#answer","text":"We just need to find the timestamp of the two auction trades and then sum up volume of all trades between these two auction trades. This can be done like: auctionTimes:exec time from simTrades where any each saleCondition like\\: \"*[O6]*\"; select sum volume from simTrades where time within auctionTimes A few notable points worth mentioning: any each saleCondition like\\: \"*[O6]*\" : This where clause identifies the open/close auction trades. exec time from simTrades... : Extract the open and close auction time as a list of two elements. The first element is the time for open auction trade and the second is for close auction trade.","title":"Answer"},{"location":"2020/2020.02.03/","text":"Introduction \u00b6 One frequently asked question in analyzing the behavior of a Smart Order Router (SOR) is how many time periods in which there is no open child orders on market and what are the start time and length of the no-slice period. The following function genOrders simulates 5,000 child orders with order submission time and the time each order exits from the limit order book. It is assumed that the trading hours is from 09:30 to 16:00 and the parent order arrives exactly at 09:30 . genOrders:{[nOrders;seed;openTime;closeTime] system \"S \",string seed; submitTimes:asc closeTime&openTime+nOrders?390*60*1000; system \"S \",string seed; exitTimes:closeTime&submitTimes+nOrders?60*1000; ([] orderId:1000+til nOrders;subT:submitTimes;exitT:exitTimes) }; openTime:`time$09:30; closeTime:`time$16:00; simOrders:genOrders[5000;-314159;openTime;closeTime]; Question \u00b6 We want to find all the time periods when there is no open child orders on market and how long each no-order period lasts. The expected output is a table which should look like: startTime periodLength 09:30:00.000 00:00:17.080 10:25:57.802 00:00:04.595 10:29:43.843 00:00:00.676 11:08:07.079 00:00:05.682 12:30:43.199 00:00:08.152 15:29:06.359 00:00:08.213 Answer \u00b6 Below is the suggested answer to this question: times:update maxT:maxs exitT from simOrders; times:update noOrderDur:subT-prev maxT from times; times:update noOrderDur:subT-openTime from times where null noOrderDur; select startTime:`time$subT-noOrderDur,periodLength:`time$noOrderDur from times where noOrderDur>0 Some detailed explanations on the suggested solution: Line 1: Find the running maximum time of order exiting from market. Line 2: Take the difference between the order submission time of each child order and the previous maximum exiting time. There is at least one open order on market if this time difference is negative. Line 3: Determine the period of no orders between market open and the time the first child order is sliced out. Line 4: Select the time period when the length of no-order period is positive.","title":"2020.02.03"},{"location":"2020/2020.02.03/#introduction","text":"One frequently asked question in analyzing the behavior of a Smart Order Router (SOR) is how many time periods in which there is no open child orders on market and what are the start time and length of the no-slice period. The following function genOrders simulates 5,000 child orders with order submission time and the time each order exits from the limit order book. It is assumed that the trading hours is from 09:30 to 16:00 and the parent order arrives exactly at 09:30 . genOrders:{[nOrders;seed;openTime;closeTime] system \"S \",string seed; submitTimes:asc closeTime&openTime+nOrders?390*60*1000; system \"S \",string seed; exitTimes:closeTime&submitTimes+nOrders?60*1000; ([] orderId:1000+til nOrders;subT:submitTimes;exitT:exitTimes) }; openTime:`time$09:30; closeTime:`time$16:00; simOrders:genOrders[5000;-314159;openTime;closeTime];","title":"Introduction"},{"location":"2020/2020.02.03/#question","text":"We want to find all the time periods when there is no open child orders on market and how long each no-order period lasts. The expected output is a table which should look like: startTime periodLength 09:30:00.000 00:00:17.080 10:25:57.802 00:00:04.595 10:29:43.843 00:00:00.676 11:08:07.079 00:00:05.682 12:30:43.199 00:00:08.152 15:29:06.359 00:00:08.213","title":"Question"},{"location":"2020/2020.02.03/#answer","text":"Below is the suggested answer to this question: times:update maxT:maxs exitT from simOrders; times:update noOrderDur:subT-prev maxT from times; times:update noOrderDur:subT-openTime from times where null noOrderDur; select startTime:`time$subT-noOrderDur,periodLength:`time$noOrderDur from times where noOrderDur>0 Some detailed explanations on the suggested solution: Line 1: Find the running maximum time of order exiting from market. Line 2: Take the difference between the order submission time of each child order and the previous maximum exiting time. There is at least one open order on market if this time difference is negative. Line 3: Determine the period of no orders between market open and the time the first child order is sliced out. Line 4: Select the time period when the length of no-order period is positive.","title":"Answer"},{"location":"2020/2020.02.10/","text":"Introduction \u00b6 Let's go one step further by continuing the question from last week. A question asked by algorithmic traders quite often is how many open orders are live on market at any given time. Question \u00b6 Find the time series of the number of open child orders. The question from last week is simply a special case of this question. The output is a table with two columns like below: startTime nOpenOrders 09:30:00.000 0 hh:mm:ss.SSS x hh:mm:ss.SSS y hh:mm:ss.SSS z Answer \u00b6 The child order count should increase by 1 at each order's submission time ( subT ) and decrease by 1 when the order is removed from the market at exit time ( exitT ). Based on this reasoning logic, three tables are created: The first table contains one row, which has order count of zero to accommodate the time period from market open to the time when the first child order is created. The second table contains all new orders. The third table records all orders which are removed from market. Along this line of thinking, the following implementation is suggested: initOrder:([] time:enlist openTime;nOpenOrders:enlist 0); addOrder:select time:subTime,nOpenOrders:1 from simOrders; removeOrder:select time:exitTime,nOpenOrders:-1 from simOrders; orders:select time,sums nOpenOrders from `time xasc initOrder,addOrder,removeOrder; select time,nOpenOrders from orders where differ nOpenOrders The where differ nOpenOrders on the last line above is required to make sure the order count between two consecutive rows are different.","title":"2020.02.10"},{"location":"2020/2020.02.10/#introduction","text":"Let's go one step further by continuing the question from last week. A question asked by algorithmic traders quite often is how many open orders are live on market at any given time.","title":"Introduction"},{"location":"2020/2020.02.10/#question","text":"Find the time series of the number of open child orders. The question from last week is simply a special case of this question. The output is a table with two columns like below: startTime nOpenOrders 09:30:00.000 0 hh:mm:ss.SSS x hh:mm:ss.SSS y hh:mm:ss.SSS z","title":"Question"},{"location":"2020/2020.02.10/#answer","text":"The child order count should increase by 1 at each order's submission time ( subT ) and decrease by 1 when the order is removed from the market at exit time ( exitT ). Based on this reasoning logic, three tables are created: The first table contains one row, which has order count of zero to accommodate the time period from market open to the time when the first child order is created. The second table contains all new orders. The third table records all orders which are removed from market. Along this line of thinking, the following implementation is suggested: initOrder:([] time:enlist openTime;nOpenOrders:enlist 0); addOrder:select time:subTime,nOpenOrders:1 from simOrders; removeOrder:select time:exitTime,nOpenOrders:-1 from simOrders; orders:select time,sums nOpenOrders from `time xasc initOrder,addOrder,removeOrder; select time,nOpenOrders from orders where differ nOpenOrders The where differ nOpenOrders on the last line above is required to make sure the order count between two consecutive rows are different.","title":"Answer"},{"location":"2020/2020.02.17/","text":"Introduction \u00b6 In the algorithmic trading world, parameterization is so common that some algorithms are configured with hundreds or thousands of parameters. An algorithmic parent order can easily has hundreds of parameters and some of which are exposed to algorithm users so that they can update the order attributes. For example, the participation rate of a POV (Percent Of Volume) order can be amended by end users at any time during the trading duration. A common question encountered in the analysis of algorithm and/or smart order router behavior is what parameters are modified, and how they are updated when an amend event is initiated by an algorithmic trader. Question \u00b6 Below is an example history of a few selected parameters of a POV order. Create a table to show the parameter history with each parameter name as the column name in the table. You need to treat the change in order quantity and/or price limit the same as parameter change. paramTbl:([]time:`time$();orderQty:`long$();limitPrice:`float$();params:()); `paramTbl insert (09:30:56.123;500000;0n;`StartTime`PovRate!(10:00:00.000;0.08)); `paramTbl insert (09:35:44.735;500000;0n;`StartTime`PovRate!(09:40:00.000;0.08)); `paramTbl insert (10:01:25.941;500000;0n;`StartTime`PovRate!(09:40:00.000;0.12)); `paramTbl insert (10:10:32.356;500000;0n;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (10:30:39.475;500000;45.23;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;600000;45.27;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;1000000;0n;`StartTime`PovRate!(09:40:00.000;0.15)); The final output table should look like as follows. Note in kdb table, the empty cell in the table below should have proper null value. time OrderQty LimitPrice StartTime PovRate MinPovRate MaxPovRate 09:30:56.123 500000 10:00:00.000 0.08 09:35:44.735 500000 09:40:00.000 0.08 10:01:25.941 500000 09:40:00.000 0.12 10:10:32.356 500000 09:40:00.000 0.12 0.1 0.14 10:30:39.475 500000 45.23 09:40:00.000 0.12 0.1 0.14 11:00:52.092 600000 45.27 09:40:00.000 0.12 0.1 0.14 11:00:52.092 1000000 09:40:00.000 0.15 Answer \u00b6 The answer below shows a few tips on dictionary manipulation: Use raze to merge a list of dictionaries with values of possible different types into a single dictionary Find the proper null values for each dictionary key Merge two dictionaries with join operator Merge two tables side by side {[paramTbl] / Merge all parameters into a single dictionary so as to get a full list of parameter names allParams:raze exec params from paramTbl; / Find the null value for each parameter name nullValues:(key allParams)!(enlist each value allParams)[;1]; / Create a table of \"parameter\" change history of order qty and limit price params1:select time,OrderQty:orderQty,LimitPrice:limitPrice from paramTbl; / Set a proper null value to parameters that are not present params2:exec {x,y}[nullValues;] each params from paramTbl; / Combine the normal parameters with the pseudo parameters params1,'params2 }[paramTbl]","title":"2020.02.17"},{"location":"2020/2020.02.17/#introduction","text":"In the algorithmic trading world, parameterization is so common that some algorithms are configured with hundreds or thousands of parameters. An algorithmic parent order can easily has hundreds of parameters and some of which are exposed to algorithm users so that they can update the order attributes. For example, the participation rate of a POV (Percent Of Volume) order can be amended by end users at any time during the trading duration. A common question encountered in the analysis of algorithm and/or smart order router behavior is what parameters are modified, and how they are updated when an amend event is initiated by an algorithmic trader.","title":"Introduction"},{"location":"2020/2020.02.17/#question","text":"Below is an example history of a few selected parameters of a POV order. Create a table to show the parameter history with each parameter name as the column name in the table. You need to treat the change in order quantity and/or price limit the same as parameter change. paramTbl:([]time:`time$();orderQty:`long$();limitPrice:`float$();params:()); `paramTbl insert (09:30:56.123;500000;0n;`StartTime`PovRate!(10:00:00.000;0.08)); `paramTbl insert (09:35:44.735;500000;0n;`StartTime`PovRate!(09:40:00.000;0.08)); `paramTbl insert (10:01:25.941;500000;0n;`StartTime`PovRate!(09:40:00.000;0.12)); `paramTbl insert (10:10:32.356;500000;0n;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (10:30:39.475;500000;45.23;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;600000;45.27;`StartTime`PovRate`MinPovRate`MaxPovRate!(09:40:00.000;0.12;0.10;0.14)); `paramTbl insert (11:00:52.092;1000000;0n;`StartTime`PovRate!(09:40:00.000;0.15)); The final output table should look like as follows. Note in kdb table, the empty cell in the table below should have proper null value. time OrderQty LimitPrice StartTime PovRate MinPovRate MaxPovRate 09:30:56.123 500000 10:00:00.000 0.08 09:35:44.735 500000 09:40:00.000 0.08 10:01:25.941 500000 09:40:00.000 0.12 10:10:32.356 500000 09:40:00.000 0.12 0.1 0.14 10:30:39.475 500000 45.23 09:40:00.000 0.12 0.1 0.14 11:00:52.092 600000 45.27 09:40:00.000 0.12 0.1 0.14 11:00:52.092 1000000 09:40:00.000 0.15","title":"Question"},{"location":"2020/2020.02.17/#answer","text":"The answer below shows a few tips on dictionary manipulation: Use raze to merge a list of dictionaries with values of possible different types into a single dictionary Find the proper null values for each dictionary key Merge two dictionaries with join operator Merge two tables side by side {[paramTbl] / Merge all parameters into a single dictionary so as to get a full list of parameter names allParams:raze exec params from paramTbl; / Find the null value for each parameter name nullValues:(key allParams)!(enlist each value allParams)[;1]; / Create a table of \"parameter\" change history of order qty and limit price params1:select time,OrderQty:orderQty,LimitPrice:limitPrice from paramTbl; / Set a proper null value to parameters that are not present params2:exec {x,y}[nullValues;] each params from paramTbl; / Combine the normal parameters with the pseudo parameters params1,'params2 }[paramTbl]","title":"Answer"},{"location":"2020/2020.02.24/","text":"Introduction \u00b6 One common operation on a dictionary is to add an new key to an existing dictionary. This operation looks quite easy and straightforward at first sight, but there is a trap to fall into. Question \u00b6 Suppose you have a dictionary d defined as follows: q) d:`firstName`lastName!`Tom`Jerry How to add a new key age with value 37 to this dictionary? After adding the new key, the updated dictionary should look like: q) d firstName| Tom lastName | Jerry age | 37 Answer \u00b6 The immediate solution that comes to many people's mind is to add the new key age is: q) d[`age]:37 Unfortunately, a type error is thrown when doing that: q) d[`age]:37 'type [0] d[`age]:37 ^ The type error occurs because: The existing dictionary d is uniform, and The value type of new item age is different from the value type of the existing items in the dictionary Let's look at two different cases. Mixed Value Type \u00b6 A new key can be simply added by assigning the value to the new key when the existing dictionary's values are of mixed types. For example, the value of dictionary d2 has types of symbol and long , i.e. , (`Tom;`Jerry;10583) is of mixed type. q) d2:`firstName`lastName`zip!(`Tom;`Jerry;10583) q) d2 firstName| `Tom lastName | `Jerry zipcode | 10583 q) d2[`age]:37 / add a new item q) d2 firstName| `Tom lastName | `Jerry zipcode | 10583 age | 37 Uniform Value Type \u00b6 The new value has the same type as the existing dictionary's value q) d3:`firstName`lastName!`Tom`Jerry q) d3[`state]:`NY q) d3 firstName| Tom lastName | Jerry state | NY The new value's type is different from the type of the existing dictionary's value. In this case, we can create a second dictionary using the new key/value and then merge this dictionary with the existing dictionary. For example, q) d4:`firstName`lastName!`Tom`Jerry q) d4 firstName| Tom lastName | Jerry q) d4,(enlist `age)!(enlist 37) firstName| `Tom lastName | `Jerry age | 37 The right side of the join operator ( , ) above is a singleton dictionary. Note that both the key and the value of a dictionary are required to be lists, you must enlist atomic value to create a singleton dictionary. A generic approach \u00b6 The q-sql update template can be used to update a dictionary: update age:37,zipcode:10583,address:\"231 Park Ave\" from d This approach is very generic and works irrespective the value types of the existing dictionary. Summary \u00b6 The robust approaches to insert a new item into an dictionary are: first create a new dictionary using the new item and merge this new dictionary with the existing dictionary using the join operator . use q-sql the update template to add new items to a dictionary or update the value of an existing item.","title":"2020.02.24"},{"location":"2020/2020.02.24/#introduction","text":"One common operation on a dictionary is to add an new key to an existing dictionary. This operation looks quite easy and straightforward at first sight, but there is a trap to fall into.","title":"Introduction"},{"location":"2020/2020.02.24/#question","text":"Suppose you have a dictionary d defined as follows: q) d:`firstName`lastName!`Tom`Jerry How to add a new key age with value 37 to this dictionary? After adding the new key, the updated dictionary should look like: q) d firstName| Tom lastName | Jerry age | 37","title":"Question"},{"location":"2020/2020.02.24/#answer","text":"The immediate solution that comes to many people's mind is to add the new key age is: q) d[`age]:37 Unfortunately, a type error is thrown when doing that: q) d[`age]:37 'type [0] d[`age]:37 ^ The type error occurs because: The existing dictionary d is uniform, and The value type of new item age is different from the value type of the existing items in the dictionary Let's look at two different cases.","title":"Answer"},{"location":"2020/2020.02.24/#mixed-value-type","text":"A new key can be simply added by assigning the value to the new key when the existing dictionary's values are of mixed types. For example, the value of dictionary d2 has types of symbol and long , i.e. , (`Tom;`Jerry;10583) is of mixed type. q) d2:`firstName`lastName`zip!(`Tom;`Jerry;10583) q) d2 firstName| `Tom lastName | `Jerry zipcode | 10583 q) d2[`age]:37 / add a new item q) d2 firstName| `Tom lastName | `Jerry zipcode | 10583 age | 37","title":"Mixed Value Type"},{"location":"2020/2020.02.24/#uniform-value-type","text":"The new value has the same type as the existing dictionary's value q) d3:`firstName`lastName!`Tom`Jerry q) d3[`state]:`NY q) d3 firstName| Tom lastName | Jerry state | NY The new value's type is different from the type of the existing dictionary's value. In this case, we can create a second dictionary using the new key/value and then merge this dictionary with the existing dictionary. For example, q) d4:`firstName`lastName!`Tom`Jerry q) d4 firstName| Tom lastName | Jerry q) d4,(enlist `age)!(enlist 37) firstName| `Tom lastName | `Jerry age | 37 The right side of the join operator ( , ) above is a singleton dictionary. Note that both the key and the value of a dictionary are required to be lists, you must enlist atomic value to create a singleton dictionary.","title":"Uniform Value Type"},{"location":"2020/2020.02.24/#a-generic-approach","text":"The q-sql update template can be used to update a dictionary: update age:37,zipcode:10583,address:\"231 Park Ave\" from d This approach is very generic and works irrespective the value types of the existing dictionary.","title":"A generic approach"},{"location":"2020/2020.02.24/#summary","text":"The robust approaches to insert a new item into an dictionary are: first create a new dictionary using the new item and merge this new dictionary with the existing dictionary using the join operator . use q-sql the update template to add new items to a dictionary or update the value of an existing item.","title":"Summary"},{"location":"2020/2020.03.02/","text":"Introduction \u00b6 The first thing to do in most quantitative analysis in the electronic trading is to determine the data scope, which covers two aspects: the sample period, i.e. the start and end date/time of the data the cross sectional space, i.e. the universe of securities included in the analysis A common approach to determine the security universe is to include the top n most actively traded symbols. Question \u00b6 Assuming a trade table, which has three columns: date , ticker and volume , is simulated with the function simulateTrades defined below. This function generates 500000 trades for all week days in March 2020. The stock ticker is generated as three random letters. The column volume indicates how many shares are traded. getTradingDays:{ firstDate:2020.03.01; lastDate:2020.03.31; dates:firstDate+til (lastDate-firstDate)+1; dates where not (dates mod 7) in 0 1 }; simulateTrades:{[seed;nTrades] tradingDays:getTradingDays[]; system \"S \",string seed; dates:nTrades?tradingDays; system \"S \",string seed; tickers:nTrades?`3; system \"S \",string seed; volumes:100*nTrades?1+til 100; ([] date:dates;ticker:tickers;volume:volumes) }; trades:simulateTrades[-314159;5000000] Find the top 10 symbols that are most actively traded (measured by total traded shares) on each day. The returned table should have 220 rows, i.e. 10 rows for each day and the following schema: topTradedSymbols:([] date:`date$(); ticker:`symbol$(); dailyVol:`long$() )","title":"2020.03.02"},{"location":"2020/2020.03.02/#introduction","text":"The first thing to do in most quantitative analysis in the electronic trading is to determine the data scope, which covers two aspects: the sample period, i.e. the start and end date/time of the data the cross sectional space, i.e. the universe of securities included in the analysis A common approach to determine the security universe is to include the top n most actively traded symbols.","title":"Introduction"},{"location":"2020/2020.03.02/#question","text":"Assuming a trade table, which has three columns: date , ticker and volume , is simulated with the function simulateTrades defined below. This function generates 500000 trades for all week days in March 2020. The stock ticker is generated as three random letters. The column volume indicates how many shares are traded. getTradingDays:{ firstDate:2020.03.01; lastDate:2020.03.31; dates:firstDate+til (lastDate-firstDate)+1; dates where not (dates mod 7) in 0 1 }; simulateTrades:{[seed;nTrades] tradingDays:getTradingDays[]; system \"S \",string seed; dates:nTrades?tradingDays; system \"S \",string seed; tickers:nTrades?`3; system \"S \",string seed; volumes:100*nTrades?1+til 100; ([] date:dates;ticker:tickers;volume:volumes) }; trades:simulateTrades[-314159;5000000] Find the top 10 symbols that are most actively traded (measured by total traded shares) on each day. The returned table should have 220 rows, i.e. 10 rows for each day and the following schema: topTradedSymbols:([] date:`date$(); ticker:`symbol$(); dailyVol:`long$() )","title":"Question"}]}